import discord
from discord.ext import commands
from discord import app_commands
from typing import Optional, Dict, Any, List
import logging
from datetime import datetime, timedelta, timezone
import asyncio
import uuid

from verselink_api import VerselinkAPI
from utils import *
from config import Config
from event_handlers import EventCreationHandler
from tournament_handlers import TournamentCreationHandler

logger = logging.getLogger(__name__)

class InteractiveSession:
    """Classe pour g√©rer une session de cr√©ation interactive"""
    
    def __init__(self, user_id: str, session_type: str):
        self.user_id = user_id
        self.session_type = session_type  # 'event' ou 'tournament'
        self.session_id = str(uuid.uuid4())
        self.data = {}
        self.step = 0
        self.created_at = datetime.utcnow()
        self.last_activity = datetime.utcnow()
        self.is_active = True
        
    def update_activity(self):
        """Met √† jour la derni√®re activit√©"""
        self.last_activity = datetime.utcnow()
        
    def is_expired(self, timeout_minutes: int = 30) -> bool:
        """V√©rifie si la session a expir√©"""
        return (datetime.utcnow() - self.last_activity).total_seconds() > (timeout_minutes * 60)

class SessionManager:
    """Gestionnaire des sessions interactives"""
    
    def __init__(self):
        self.sessions: Dict[str, InteractiveSession] = {}
        
    def create_session(self, user_id: str, session_type: str) -> InteractiveSession:
        """Cr√©e une nouvelle session"""
        # Termine les sessions existantes pour cet utilisateur
        self.end_user_sessions(user_id)
        
        session = InteractiveSession(user_id, session_type)
        self.sessions[session.session_id] = session
        return session
        
    def get_session(self, user_id: str) -> Optional[InteractiveSession]:
        """R√©cup√®re la session active d'un utilisateur"""
        for session in self.sessions.values():
            if session.user_id == user_id and session.is_active:
                if session.is_expired():
                    session.is_active = False
                    continue
                return session
        return None
        
    def end_session(self, session_id: str):
        """Termine une session"""
        if session_id in self.sessions:
            self.sessions[session_id].is_active = False
            
    def end_user_sessions(self, user_id: str):
        """Termine toutes les sessions d'un utilisateur"""
        for session in self.sessions.values():
            if session.user_id == user_id:
                session.is_active = False
                
    def cleanup_expired(self):
        """Nettoie les sessions expir√©es"""
        expired = [sid for sid, session in self.sessions.items() if session.is_expired()]
        for sid in expired:
            self.sessions[sid].is_active = False

class EventCreationView(discord.ui.View):
    """Interface pour s√©lectionner le type d'√©v√©nement"""
    
    def __init__(self, session_manager: SessionManager):
        super().__init__(timeout=300.0)
        self.session_manager = session_manager
        
    @discord.ui.select(
        placeholder="Choisissez le type d'√©v√©nement...",
        min_values=1,
        max_values=1,
        options=[
            discord.SelectOption(label="üéØ Raid PvE", value="raid", description="Op√©ration PvE contre l'IA"),
            discord.SelectOption(label="üèÅ Course", value="course", description="Course de vaisseaux"),
            discord.SelectOption(label="‚öîÔ∏è Combat PvP", value="pvp", description="Combat joueur contre joueur"),
            discord.SelectOption(label="üî´ FPS", value="fps", description="Combat au sol FPS"),
            discord.SelectOption(label="üîß Salvaging", value="salvaging", description="R√©cup√©ration et salvage"),
            discord.SelectOption(label="üì¶ Logistique", value="logistique", description="Transport et livraison"),
            discord.SelectOption(label="üåç Exploration", value="exploration", description="D√©couverte de nouveaux syst√®mes"),
            discord.SelectOption(label="‚õèÔ∏è Mining", value="mining", description="Extraction mini√®re"),
            discord.SelectOption(label="üíº Trading", value="trading", description="Commerce et n√©goce"),
            discord.SelectOption(label="üé≠ Roleplay", value="roleplay", description="√âv√©nement roleplay"),
            discord.SelectOption(label="üìã Autre", value="autre", description="Autre type d'√©v√©nement")
        ]
    )
    async def select_event_type(self, interaction: discord.Interaction, select: discord.ui.Select):
        session = self.session_manager.get_session(str(interaction.user.id))
        if not session or session.session_type != 'event':
            await interaction.response.send_message("‚ùå Session expir√©e. Veuillez recommencer avec `/create-event`.", ephemeral=True)
            return
            
        session.data['type'] = select.values[0]
        session.update_activity()
        
        type_names = {
            'raid': 'Raid PvE', 'course': 'Course', 'pvp': 'Combat PvP', 'fps': 'Combat FPS',
            'salvaging': 'Salvaging', 'logistique': 'Logistique', 'exploration': 'Exploration',
            'mining': 'Mining', 'trading': 'Trading', 'roleplay': 'Roleplay', 'autre': 'Autre'
        }
        
        embed = create_success_embed(
            "‚úÖ Type d'√©v√©nement s√©lectionn√©",
            f"Vous avez choisi : **{type_names[select.values[0]]}**\n\n"
            f"Maintenant, envoyez-moi le **titre** de votre √©v√©nement en message priv√©.\n"
            f"üìù *Exemple: \"Raid sur Jumptown - Op√©ration Nettoyage\"*"
        )
        
        await interaction.response.edit_message(embed=embed, view=None)
        
        # Envoie un MP pour la suite
        try:
            dm_embed = create_info_embed(
                "üìù Titre de l'√©v√©nement",
                f"Parfait ! Votre √©v√©nement sera de type **{type_names[select.values[0]]}**.\n\n"
                f"Maintenant, envoyez-moi le **titre** de votre √©v√©nement.\n\n"
                f"üí° **Conseils pour un bon titre :**\n"
                f"‚Ä¢ Soyez pr√©cis et accrocheur\n"
                f"‚Ä¢ Mentionnez le lieu si important\n"
                f"‚Ä¢ Indiquez le niveau si n√©cessaire\n\n"
                f"üìù **Exemples :**\n"
                f"‚Ä¢ \"Raid Jumptown - Op√©ration Nettoyage\"\n"
                f"‚Ä¢ \"Course Murray Cup - Qualification\"\n"
                f"‚Ä¢ \"Exploration Pyro - Premi√®re Exp√©dition\"\n\n"
                f"‚è∞ *Vous avez 10 minutes pour r√©pondre*"
            )
            await interaction.user.send(embed=dm_embed)
        except discord.Forbidden:
            embed = create_error_embed(
                "‚ùå Impossible d'envoyer un MP",
                "Je ne peux pas vous envoyer de message priv√©. Veuillez activer les MPs ou continuer ici.\n\n"
                f"Envoyez votre titre d'√©v√©nement dans ce canal."
            )
            await interaction.edit_original_response(embed=embed)

class InteractiveEvents(commands.Cog):
    """Syst√®me interactif de cr√©ation d'√©v√©nements et tournois"""
    
    def __init__(self, bot: commands.Bot):
        self.bot = bot
        self.api = VerselinkAPI()
        self.session_manager = SessionManager()
        
        # Gestionnaires sp√©cialis√©s
        self.event_handler = EventCreationHandler(self.api, self.bot)
        self.tournament_handler = TournamentCreationHandler(self.api)
        
    async def cog_load(self):
        """Initialize the cog"""
        logger.info("Interactive Events cog loaded")
        # D√©marrer le nettoyage p√©riodique des sessions
        self.cleanup_task = asyncio.create_task(self.cleanup_expired_sessions())
        
    async def cog_unload(self):
        """Cleanup when cog is unloaded"""
        if hasattr(self, 'cleanup_task'):
            self.cleanup_task.cancel()
        if self.api.session:
            await self.api.session.close()
            
    async def cleanup_expired_sessions(self):
        """Nettoie p√©riodiquement les sessions expir√©es"""
        while True:
            try:
                await asyncio.sleep(300)  # Toutes les 5 minutes
                self.session_manager.cleanup_expired()
            except asyncio.CancelledError:
                break
            except Exception as e:
                logger.error(f"Error cleaning up sessions: {e}")
    
    @app_commands.command(name="create-event", description="Cr√©er un √©v√©nement de mani√®re interactive")
    async def create_event_interactive(self, interaction: discord.Interaction):
        """Commande pour cr√©er un √©v√©nement de mani√®re interactive"""
        await interaction.response.defer(ephemeral=True)
        
        # V√©rifier si l'utilisateur a d√©j√† une session active
        existing_session = self.session_manager.get_session(str(interaction.user.id))
        if existing_session:
            embed = create_warning_embed(
                "‚ö†Ô∏è Session active",
                f"Vous avez d√©j√† une session de cr√©ation **{existing_session.session_type}** en cours.\n\n"
                f"Tapez `annuler` dans nos MPs pour l'annuler, ou continuez votre cr√©ation actuelle."
            )
            await interaction.followup.send(embed=embed)
            return
        
        # Cr√©er une nouvelle session
        session = self.session_manager.create_session(str(interaction.user.id), 'event')
        
        embed = create_embed(
            "üéØ Cr√©ation d'√âv√©nement Interactive",
            "Bienvenue dans l'assistant de cr√©ation d'√©v√©nements !\n\n"
            "Je vais vous guider √©tape par √©tape pour cr√©er votre √©v√©nement parfait.\n"
            "Commen√ßons par choisir le type d'√©v√©nement :",
            color=0x3B82F6
        )
        
        view = EventCreationView(self.session_manager)
        await interaction.followup.send(embed=embed, view=view)
        
    @app_commands.command(name="create-tournament", description="Cr√©er un tournoi de mani√®re interactive")
    async def create_tournament_interactive(self, interaction: discord.Interaction):
        """Commande pour cr√©er un tournoi de mani√®re interactive"""
        await interaction.response.defer(ephemeral=True)
        
        # V√©rifier si l'utilisateur a d√©j√† une session active
        existing_session = self.session_manager.get_session(str(interaction.user.id))
        if existing_session:
            embed = create_warning_embed(
                "‚ö†Ô∏è Session active",
                f"Vous avez d√©j√† une session de cr√©ation **{existing_session.session_type}** en cours.\n\n"
                f"Tapez `annuler` dans nos MPs pour l'annuler, ou continuez votre cr√©ation actuelle."
            )
            await interaction.followup.send(embed=embed)
            return
        
        # Cr√©er une nouvelle session pour tournoi
        session = self.session_manager.create_session(str(interaction.user.id), 'tournament')
        
        embed = create_embed(
            "üèÜ Cr√©ation de Tournoi Interactive",
            "Bienvenue dans l'assistant de cr√©ation de tournois !\n\n"
            "Je vais vous guider pour cr√©er votre tournoi comp√©titif.\n"
            "Commen√ßons par me dire le **nom** de votre tournoi en message priv√©.",
            color=0xF59E0B
        )
        
        await interaction.followup.send(embed=embed)
        
        # Envoyer le premier MP
        try:
            dm_embed = create_info_embed(
                "üèÜ Nom du tournoi",
                "Parfait ! Commen√ßons par le nom de votre tournoi.\n\n"
                "üí° **Conseils pour un bon nom :**\n"
                "‚Ä¢ Soyez cr√©atif et m√©morable\n"
                "‚Ä¢ Mentionnez le jeu/mode si n√©cessaire\n"
                "‚Ä¢ Indiquez la p√©riode ou saison\n\n"
                "üìù **Exemples :**\n"
                "‚Ä¢ \"Championnat Star Citizen 2025\"\n"
                "‚Ä¢ \"Tournoi Racing Murray Cup\"\n"
                "‚Ä¢ \"Arena Commander Masters\"\n\n"
                "‚è∞ *Vous avez 10 minutes pour r√©pondre*"
            )
            await interaction.user.send(embed=dm_embed)
        except discord.Forbidden:
            embed = create_error_embed(
                "‚ùå Impossible d'envoyer un MP",
                "Je ne peux pas vous envoyer de message priv√©. Veuillez activer les MPs."
            )
            await interaction.edit_original_response(embed=embed)
            self.session_manager.end_session(session.session_id)
    
    @commands.Cog.listener()
    async def on_message(self, message: discord.Message):
        """√âcoute les messages pour les sessions interactives"""
        # Ignorer les messages du bot
        if message.author.bot:
            return
            
        # V√©rifier si c'est un MP et si l'utilisateur a une session active
        if isinstance(message.channel, discord.DMChannel):
            session = self.session_manager.get_session(str(message.author.id))
            if session and session.is_active:
                await self.handle_session_message(message, session)
    
    async def handle_session_message(self, message: discord.Message, session: InteractiveSession):
        """G√®re les messages dans le contexte d'une session"""
        session.update_activity()
        
        # Commandes sp√©ciales
        content = message.content.lower().strip()
        if content in ['annuler', 'cancel', 'stop', 'quit']:
            await self.cancel_session(message, session)
            return
        elif content in ['aide', 'help', '?']:
            await self.send_help(message, session)
            return
        elif content in ['status', 'statut', '√©tat']:
            await self.send_status(message, session)
            return
            
        # Traiter selon le type de session
        if session.session_type == 'event':
            await self.event_handler.handle_event_message(message, session)
        elif session.session_type == 'tournament':
            await self.tournament_handler.handle_tournament_message(message, session)
    
    async def cancel_session(self, message: discord.Message, session: InteractiveSession):
        """Annule une session"""
        self.session_manager.end_session(session.session_id)
        
        embed = create_success_embed(
            "‚úÖ Session annul√©e",
            f"Votre session de cr√©ation de **{session.session_type}** a √©t√© annul√©e.\n\n"
            f"Vous pouvez recommencer √† tout moment avec `/create-{session.session_type}`."
        )
        await message.channel.send(embed=embed)
    
    async def send_help(self, message: discord.Message, session: InteractiveSession):
        """Envoie l'aide pour une session"""
        embed = create_info_embed(
            "ü§ñ Aide - Session Interactive",
            f"Vous √™tes en train de cr√©er un **{session.session_type}**.\n\n"
            f"**Commandes disponibles :**\n"
            f"‚Ä¢ `annuler` - Annuler la cr√©ation\n"
            f"‚Ä¢ `status` - Voir l'√©tat actuel\n"
            f"‚Ä¢ `aide` - Voir cette aide\n\n"
            f"**Progression :** {len(session.data)}/10 √©tapes compl√©t√©es\n\n"
            f"Continuez en r√©pondant √† la derni√®re question pos√©e."
        )
        await message.channel.send(embed=embed)
    
    async def send_status(self, message: discord.Message, session: InteractiveSession):
        """Envoie le statut d'une session"""
        steps_completed = len(session.data)
        total_steps = len(self.event_steps) if session.session_type == 'event' else len(self.tournament_steps)
        
        embed = create_info_embed(
            f"üìä Statut - Cr√©ation de {session.session_type.title()}",
            f"**Progression :** {steps_completed}/{total_steps} √©tapes\n\n"
            f"**Donn√©es collect√©es :**\n"
        )
        
        for key, value in session.data.items():
            if key == 'description' and len(str(value)) > 100:
                value = str(value)[:100] + "..."
            embed.description += f"‚Ä¢ **{key.title()}**: {value}\n"
        
        await message.channel.send(embed=embed)

async def setup(bot: commands.Bot):
    """Setup function for the cog"""
    await bot.add_cog(InteractiveEvents(bot))