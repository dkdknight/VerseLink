import discord
from discord.ext import commands
from discord import app_commands
from typing import Optional, List
import logging
from datetime import datetime, timedelta

from verselink_api import VerselinkAPI
from utils import *
from config import Config

logger = logging.getLogger(__name__)

class EventManagement(commands.Cog):
    """Commandes de gestion des √©v√©nements existants"""
    
    def __init__(self, bot: commands.Bot):
        self.bot = bot
        self.api = VerselinkAPI()
    
    async def cog_load(self):
        """Initialize the cog"""
        logger.info("Event Management cog loaded")
        
    async def cog_unload(self):
        """Cleanup when cog is unloaded"""
        if self.api.session:
            await self.api.session.close()
    
    @app_commands.command(name="event-start", description="D√©marrer un √©v√©nement")
    @app_commands.describe(event_id="ID de l'√©v√©nement √† d√©marrer")
    @has_manage_guild()
    async def start_event(self, interaction: discord.Interaction, event_id: str):
        """D√©marre un √©v√©nement"""
        await interaction.response.defer()
        
        try:
            async with VerselinkAPI() as api:
                # V√©rifier que l'√©v√©nement existe
                event = await api.get_event(event_id)
                
                # D√©marrer l'√©v√©nement
                result = await api.start_event(event_id)
            
            embed = create_success_embed(
                "üöÄ √âv√©nement d√©marr√©",
                f"L'√©v√©nement **{event['title']}** a √©t√© d√©marr√© avec succ√®s !\n\n"
                f"üìÖ **D√©but :** <t:{int(datetime.fromisoformat(event['start_at_utc']).timestamp())}:F>\n"
                f"üë• **Participants :** {event.get('confirmed_count', 0)}\n\n"
                f"Les participants ont √©t√© notifi√©s."
            )
            
            await interaction.followup.send(embed=embed)
            
        except Exception as e:
            embed = create_error_embed(
                "‚ùå Erreur",
                f"Impossible de d√©marrer l'√©v√©nement :\n{str(e)}"
            )
            await interaction.followup.send(embed=embed)
    
    @app_commands.command(name="event-cancel", description="Annuler un √©v√©nement")
    @app_commands.describe(
        event_id="ID de l'√©v√©nement √† annuler",
        reason="Raison de l'annulation (optionnel)"
    )
    @has_manage_guild()
    async def cancel_event(self, interaction: discord.Interaction, event_id: str, reason: Optional[str] = None):
        """Annule un √©v√©nement"""
        await interaction.response.defer()
        
        try:
            async with VerselinkAPI() as api:
                # V√©rifier que l'√©v√©nement existe
                event = await api.get_event(event_id)
                
                # Annuler l'√©v√©nement
                result = await api.cancel_event(event_id)
            
            embed = create_warning_embed(
                "üö´ √âv√©nement annul√©",
                f"L'√©v√©nement **{event['title']}** a √©t√© annul√©.\n\n"
                f"üìÖ **√âtait pr√©vu :** <t:{int(datetime.fromisoformat(event['start_at_utc']).timestamp())}:F>\n"
                f"üë• **Participants affect√©s :** {event.get('confirmed_count', 0)}\n"
                + (f"üìù **Raison :** {reason}\n" if reason else "") +
                f"\nTous les participants ont √©t√© notifi√©s de l'annulation."
            )
            
            await interaction.followup.send(embed=embed)
            
        except Exception as e:
            embed = create_error_embed(
                "‚ùå Erreur",
                f"Impossible d'annuler l'√©v√©nement :\n{str(e)}"
            )
            await interaction.followup.send(embed=embed)
    
    @app_commands.command(name="event-edit", description="Modifier un √©v√©nement existant")
    @app_commands.describe(event_id="ID de l'√©v√©nement √† modifier")
    @has_manage_guild()
    async def edit_event(self, interaction: discord.Interaction, event_id: str):
        """Lance l'√©dition interactive d'un √©v√©nement"""
        await interaction.response.defer(ephemeral=True)
        
        try:
            async with VerselinkAPI() as api:
                event = await api.get_event(event_id)
            
            embed = create_info_embed(
                "üìù √âdition d'√©v√©nement",
                f"√âdition de **{event['title']}**\n\n"
                f"Je vais vous envoyer un message priv√© pour modifier cet √©v√©nement.\n"
                f"Les participants seront notifi√©s des changements importants."
            )
            
            await interaction.followup.send(embed=embed)
            
            # Envoyer les options d'√©dition en MP
            try:
                dm_embed = create_embed(
                    "üìù √âdition d'√©v√©nement",
                    f"**√âv√©nement :** {event['title']}\n"
                    f"**Organisation :** {event.get('org_name', 'N/A')}\n"
                    f"**Date actuelle :** <t:{int(datetime.fromisoformat(event['start_at_utc']).timestamp())}:F>\n\n"
                    f"**Que voulez-vous modifier ?**\n"
                    f"‚Ä¢ `titre` - Changer le titre\n"
                    f"‚Ä¢ `description` - Modifier la description\n"
                    f"‚Ä¢ `date` - Reprogrammer l'√©v√©nement\n"
                    f"‚Ä¢ `dur√©e` - Changer la dur√©e\n"
                    f"‚Ä¢ `lieu` - Modifier le lieu\n"
                    f"‚Ä¢ `participants` - Changer le nombre max\n"
                    f"‚Ä¢ `visibilit√©` - Changer qui peut voir l'√©v√©nement\n\n"
                    f"Tapez ce que vous voulez modifier, ou `annuler` pour arr√™ter."
                )
                await interaction.user.send(embed=dm_embed)
                
                # TODO: Impl√©menter la logique d'√©dition interactive
                # Pour l'instant, on indique que c'est en d√©veloppement
                await interaction.user.send("üöß **Fonction en d√©veloppement**\nL'√©dition interactive sera disponible dans une prochaine mise √† jour.\n\nEn attendant, vous pouvez recr√©er l'√©v√©nement ou utiliser l'interface web.")
                
            except discord.Forbidden:
                embed = create_error_embed(
                    "‚ùå Impossible d'envoyer un MP",
                    "Je ne peux pas vous envoyer de message priv√©.\n\n"
                    "Utilisez l'interface web pour modifier l'√©v√©nement :\n"
                    f"[Modifier l'√©v√©nement](http://localhost:3000/events/{event_id}/edit)"
                )
                await interaction.edit_original_response(embed=embed)
        
        except Exception as e:
            embed = create_error_embed(
                "‚ùå √âv√©nement non trouv√©",
                f"Impossible de trouver l'√©v√©nement `{event_id}` :\n{str(e)}"
            )
            await interaction.followup.send(embed=embed)
    
    @app_commands.command(name="event-participants", description="Voir les participants d'un √©v√©nement")
    @app_commands.describe(event_id="ID de l'√©v√©nement")
    async def event_participants(self, interaction: discord.Interaction, event_id: str):
        """Affiche la liste des participants"""
        await interaction.response.defer()
        
        try:
            async with VerselinkAPI() as api:
                event = await api.get_event(event_id)
            
            if not event.get('signups'):
                embed = create_info_embed(
                    f"üë• Participants - {event['title']}",
                    "Aucun participant inscrit pour le moment."
                )
                await interaction.followup.send(embed=embed)
                return
            
            # Organiser les participants par statut
            confirmed = [s for s in event['signups'] if s['status'] == 'confirmed']
            waitlist = [s for s in event['signups'] if s['status'] == 'waitlist']
            checked_in = [s for s in event['signups'] if s['status'] == 'checked_in']
            
            embed = create_embed(
                f"üë• Participants - {event['title']}",
                f"**Total inscrit :** {len(event['signups'])}\n"
                f"**Confirm√©s :** {len(confirmed)}\n"
                f"**En attente :** {len(waitlist)}\n"
                f"**Pr√©sents :** {len(checked_in)}"
            )
            
            # Ajouter les participants confirm√©s
            if confirmed:
                confirmed_list = []
                for signup in confirmed[:10]:  # Limiter √† 10 pour √©viter de d√©passer la limite
                    role_info = f" ({signup['role_name']})" if signup.get('role_name') else ""
                    confirmed_list.append(f"‚Ä¢ {signup['user_handle']}{role_info}")
                
                embed.add_field(
                    name="‚úÖ Confirm√©s",
                    value="\n".join(confirmed_list) + (f"\n... et {len(confirmed) - 10} autres" if len(confirmed) > 10 else ""),
                    inline=False
                )
            
            # Ajouter la liste d'attente si elle existe
            if waitlist:
                waitlist_list = []
                for signup in waitlist[:5]:
                    waitlist_list.append(f"‚Ä¢ {signup['user_handle']}")
                
                embed.add_field(
                    name="‚è≥ Liste d'attente",
                    value="\n".join(waitlist_list) + (f"\n... et {len(waitlist) - 5} autres" if len(waitlist) > 5 else ""),
                    inline=False
                )
            
            embed.add_field(
                name="üîó Voir tous les d√©tails",
                value=f"[Page compl√®te de l'√©v√©nement](http://localhost:3000/events/{event_id})",
                inline=False
            )
            
            await interaction.followup.send(embed=embed)
            
        except Exception as e:
            embed = create_error_embed(
                "‚ùå Erreur",
                f"Impossible de r√©cup√©rer les participants :\n{str(e)}"
            )
            await interaction.followup.send(embed=embed)
    
    @app_commands.command(name="join-event", description="S'inscrire √† un √©v√©nement")
    @app_commands.describe(
        event_id="ID de l'√©v√©nement",
        role="R√¥le souhait√© (optionnel)",
        notes="Notes pour l'organisateur (optionnel)"
    )
    async def join_event(self, interaction: discord.Interaction, event_id: str, role: Optional[str] = None, notes: Optional[str] = None):
        """Inscription √† un √©v√©nement"""
        await interaction.response.defer(ephemeral=True)
        
        try:
            # Donn√©es d'inscription
            signup_data = {}
            if role:
                signup_data['preferred_role'] = role
            if notes:
                signup_data['notes'] = notes
            
            async with VerselinkAPI() as api:
                # S'inscrire √† l'√©v√©nement
                result = await api.join_event(event_id, str(interaction.user.id))
                
                # R√©cup√©rer les d√©tails de l'√©v√©nement
                event = await api.get_event(event_id)
            
            embed = create_success_embed(
                "‚úÖ Inscription confirm√©e",
                f"Vous √™tes inscrit √† **{event['title']}** !\n\n"
                f"üìÖ **Date :** <t:{int(datetime.fromisoformat(event['start_at_utc']).timestamp())}:F>\n"
                f"üìç **Lieu :** {event.get('location', 'Non sp√©cifi√©')}\n"
                + (f"üé≠ **R√¥le :** {role}\n" if role else "") +
                f"\nVous recevrez des rappels avant l'√©v√©nement."
            )
            
            await interaction.followup.send(embed=embed)
            
        except Exception as e:
            if "already" in str(e).lower():
                embed = create_warning_embed(
                    "‚ö†Ô∏è D√©j√† inscrit",
                    "Vous √™tes d√©j√† inscrit √† cet √©v√©nement."
                )
            elif "full" in str(e).lower():
                embed = create_warning_embed(
                    "‚ö†Ô∏è √âv√©nement complet",
                    "Cet √©v√©nement est complet. Vous avez √©t√© ajout√© √† la liste d'attente."
                )
            else:
                embed = create_error_embed(
                    "‚ùå Erreur d'inscription",
                    f"Impossible de vous inscrire :\n{str(e)}"
                )
            await interaction.followup.send(embed=embed)
    
    @app_commands.command(name="leave-event", description="Se d√©sinscrire d'un √©v√©nement")
    @app_commands.describe(event_id="ID de l'√©v√©nement")
    async def leave_event(self, interaction: discord.Interaction, event_id: str):
        """D√©sinscription d'un √©v√©nement"""
        await interaction.response.defer(ephemeral=True)
        
        try:
            async with VerselinkAPI() as api:
                # Se d√©sinscrire
                result = await api.leave_event(event_id, str(interaction.user.id))
                
                # R√©cup√©rer les d√©tails de l'√©v√©nement
                event = await api.get_event(event_id)
            
            embed = create_success_embed(
                "‚úÖ D√©sinscription confirm√©e",
                f"Vous √™tes d√©sinscrit de **{event['title']}**.\n\n"
                f"Vous ne recevrez plus de notifications pour cet √©v√©nement."
            )
            
            await interaction.followup.send(embed=embed)
            
        except Exception as e:
            embed = create_error_embed(
                "‚ùå Erreur de d√©sinscription",
                f"Impossible de vous d√©sinscrire :\n{str(e)}"
            )
            await interaction.followup.send(embed=embed)
    
    @app_commands.command(name="my-events", description="Voir mes √©v√©nements √† venir")
    async def my_events(self, interaction: discord.Interaction):
        """Affiche les √©v√©nements de l'utilisateur"""
        await interaction.response.defer(ephemeral=True)
        
        try:
            async with VerselinkAPI() as api:
                # R√©cup√©rer les √©v√©nements de l'utilisateur
                events = await api.get_user_events(str(interaction.user.id))
            
            if not events:
                embed = create_info_embed(
                    "üìÖ Mes √©v√©nements",
                    "Vous n'√™tes inscrit √† aucun √©v√©nement √† venir.\n\n"
                    f"D√©couvrez les √©v√©nements disponibles avec `/events`"
                )
                await interaction.followup.send(embed=embed)
                return
            
            embed = create_embed(
                f"üìÖ Mes √©v√©nements ({len(events)})",
                f"Vos {len(events)} prochains √©v√©nements :"
            )
            
            for event in events[:5]:  # Limiter √† 5
                start_time = datetime.fromisoformat(event['start_at_utc'])
                status_emoji = {
                    'confirmed': '‚úÖ',
                    'waitlist': '‚è≥',
                    'checked_in': 'üéØ'
                }.get(event.get('my_status', 'confirmed'), 'üìÖ')
                
                embed.add_field(
                    name=f"{status_emoji} {event['title']}",
                    value=f"**Date :** <t:{int(start_time.timestamp())}:R>\n"
                          f"**Lieu :** {event.get('location', 'Non sp√©cifi√©')}\n"
                          f"**Statut :** {event.get('my_status', 'Inscrit').title()}",
                    inline=False
                )
            
            if len(events) > 5:
                embed.add_field(
                    name="üîó Voir tous mes √©v√©nements",
                    value=f"[Interface web compl√®te](http://localhost:3000/profile/events)",
                    inline=False
                )
            
            await interaction.followup.send(embed=embed)
            
        except Exception as e:
            embed = create_error_embed(
                "‚ùå Erreur",
                f"Impossible de r√©cup√©rer vos √©v√©nements :\n{str(e)}"
            )
            await interaction.followup.send(embed=embed)

async def setup(bot: commands.Bot):
    """Setup function for the cog"""
    await bot.add_cog(EventManagement(bot))